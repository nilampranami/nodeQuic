/// <reference types="node" />
export class Http2WebTransportSession {
    /**
     * @param {{stream?: Http2Stream, ws?: WebSocket, isclient:boolean,
     * createParser:import('../types.js').CreateParserFunction
     * sendWindowOffset: Number,
     * receiveWindowOffset: Number,
     * shouldAutoTuneReceiveWindow: boolean
     * receiveWindowSizeLimit: Number,
     * initialBidirectionalSendStreams: Number,
     * initialBidirectionalReceiveStreams: Number,
     * initialUnidirectionalSendStreams: Number,
     * initialUnidirectionalReceiveStreams: Number}} args
     * */
    constructor({ stream, ws, isclient, createParser, sendWindowOffset, receiveWindowOffset, shouldAutoTuneReceiveWindow, receiveWindowSizeLimit, initialBidirectionalSendStreams, initialBidirectionalReceiveStreams, initialUnidirectionalSendStreams, initialUnidirectionalReceiveStreams }: {
        stream?: Http2Stream;
        ws?: WebSocket;
        isclient: boolean;
        createParser: import('../types.js').CreateParserFunction;
        sendWindowOffset: number;
        receiveWindowOffset: number;
        shouldAutoTuneReceiveWindow: boolean;
        receiveWindowSizeLimit: number;
        initialBidirectionalSendStreams: number;
        initialBidirectionalReceiveStreams: number;
        initialUnidirectionalSendStreams: number;
        initialUnidirectionalReceiveStreams: number;
    });
    jsobj: any;
    stream: import("http2").Http2Stream | undefined;
    ws: WebSocket | undefined;
    capsParser: ParserBase;
    isclient: boolean;
    flowController: FlowController;
    streamIdMngrUni: StreamIdManager;
    streamIdMngrBi: StreamIdManager;
    orderUniStreams: number;
    orderBiStreams: number;
    sendInitialParameters(): void;
    /**
     * @param {Uint8Array} chunk
     */
    writeDatagram(chunk: Uint8Array): void;
    trySendingUnidirectionalStreams(): void;
    /**
     * @param {{sendGroup:  WebTransportSendGroup|null, sendOrder: number, waitUntilAvailable: boolean}} opts
     */
    orderUnidiStream({ sendGroup, sendOrder, waitUntilAvailable }: {
        sendGroup: WebTransportSendGroup | null;
        sendOrder: number;
        waitUntilAvailable: boolean;
    }): boolean;
    trySendingBidirectionalStreams(): void;
    /**
     * @param {{sendGroup:  WebTransportSendGroup|null, sendOrder: number, waitUntilAvailable: boolean}} opts
     */
    orderBidiStream({ sendGroup, sendOrder, waitUntilAvailable }: {
        sendGroup: WebTransportSendGroup | null;
        sendOrder: number;
        waitUntilAvailable: boolean;
    }): boolean;
    orderSessionStats(): void;
    orderDatagramStats(): void;
    notifySessionDraining(): void;
    /**
     * @param {{ code: number, reason: string }} arg
     */
    close({ code, reason }: {
        code: number;
        reason: string;
    }): void;
    /**
     * @param {bigint} windowOffset
     */
    sendWindowUpdate(windowOffset: bigint): void;
    /**
     * @param {bigint} pos
     */
    reportBlocked(pos: bigint): void;
    /**
     * @param {bigint} windowOffset
     */
    sendBlocked(windowOffset: bigint): void;
    connected(): boolean;
    /**
     * @param {{ code: number, reason: string }} arg
     */
    closeConnection({ code, reason }: {
        code: number;
        reason: string;
    }): void;
    smoothedRtt(): any;
    /**
     * @returns {boolean}
     */
    canSendMaxStreams(): boolean;
    /**
     * @param {bigint} maxStreams
     * @param {boolean} unidirectional
     */
    sendMaxStreams(maxStreams: bigint, unidirectional: boolean): void;
}
export type Http2Stream = import('http2').Http2Stream;
export type WebTransportSendGroup = import('../dom.js').WebTransportSendGroup;
import { ParserBase } from "./parserbase.js";
import { FlowController } from "./flowcontroller.js";
import { StreamIdManager } from "./streamidmanager.js";
//# sourceMappingURL=session.d.ts.map